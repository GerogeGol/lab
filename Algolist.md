# Алгоритм для вычисления числа $\pi$ 
1. **Инициализация:**
   - Создать глобальную переменную `incircle` для подсчета точек внутри четверти единичной окружности.
   - Инициализировать мьютекс `mutex` для защиты доступа к `incircle`.

2. **Определение функции `pi`:**
   - Каждый поток выполняет следующее:
     - Получить количество точек, которые будет генерировать поток.
     - Инициализировать локальную переменную `incircle_thread` для подсчета точек внутри окружности.
     - Генерировать случайные координаты $(x, y)$ в диапазоне от 0 до 1.
     - Проверить, попадает ли точка в единичную окружность: если $x^2 + y^2 < 1$, увеличить `incircle_thread`.
     - Заблокировать мьютекс и добавить `incircle_thread` к глобальной переменной `incircle`.
     - Разблокировать мьютекс.

3. **Создание потоков:**
   - Разделить общее количество испытаний `ntrials` на количество потоков `nthreads` для определения количества точек, генерируемых каждым потоком.
   - Создать массив потоков `threads`.
   - Запустить первый поток с дополнительным количеством точек (остаток от деления) и остальные потоки с равным количеством точек.

4. **Ожидание завершения потоков:**
   - Для каждого потока в массиве `threads`, дождаться его завершения.

5. **Вывод результата:**
   - Аппроксимировать число $\pi$ по формуле $\hat{\pi} = 4 \times \frac{\text{incircle}}{\text{ntrials}}$.
   - Вывести значение числа $\hat{\pi}$ и время выполнения.

6. **Завершение:**
   - Уничтожить мьютекс.

# Алгоритм генерации множества Мандельброта
## Входные параметры:
- Количество потоков `nthreads`
- Количество точек `npoints`

1. Задать границы для действительной и мнимой частей: $$\text{Re}\ c \in [-2, 1],\ \text{Im}\ c \in [-1, 1]$$
2. Распределить количество точек по потокам:
     - Вычислить количество точек для генерации одним потоком
	 - Передать соответствующий диапазон индексов потоку

3. Для каждой точки в диапазоне:
   - Генерировать случайные $\text{Re}\ c$ и $\text{Im}\ c$ в заданных границах.
   - Установить начальные значения $\text{Re}\ z_0 = 0$ и $\text{Im}\  z_0 = 0$.

4. Последовательно проверяем, принадлежит ли точка множеству Мандельброта:
   - Для каждой точки выполняем до фиксированного максимального числа шагов.
     - Вычисляем:
      $$\begin{align} 
      \text{Re}\ z_{n+1} &= (\text{Re}\ z_n)^2 - (\text{Im}\ z)^2 + \text{Re}\ c \\ 
      \text{Im}\ z_{n+1} &= 2 \cdot \text{Re}\ z_n \cdot \text{Im}\ z_n + \text{Im}\ c 
      \end{align} $$
      
     - Проверяем условие выхода из множества Мандельброта:
      $$\left(\text{Re}\ z_{n+1}\right)^2 + \left(\text{Im}\ z_{n+1}\right)^2 \geq 4 \text{}$$

5. Если в результате итераций $z_{n+1}$ не отвергается, то записываем $c$ в массив для вывода.

6. Повторяем шаги $3-5$ для каждого потока.

7.  Сохранить результат в файл `mandelbrot.csv`.

### Описание реализации `rwlock`

1. **Заголовочный файл:**
   - `#ifndef MY_RWLOCK` / `#define MY_RWLOCK`: Предотвращает многократное включение заголовочного файла.
   - `#include <pthread.h>`: Подключает библиотеку POSIX threads.
   - `#include <stdbool.h>`: Подключает поддержку булевых типов.

2. **Структура `rwlock_t`:**
   - `pthread_mutex_t mutex`: Мьютекс для синхронизации доступа к rwlock.
   - `pthread_cond_t readers`: Условная переменная для читателей.
   - `pthread_cond_t writers`: Условная переменная для писателей.
   - `int readers_count`: Количество активных читателей.
   - `int writers_waiting`: Количество ожидающих писателей.
   - `int writer_active`: Флаг, указывающий на активного писателя.

3. **Функция инициализации:**
   - `void rwlock_init(rwlock_t* lock)`:
     - Инициализирует rwlock.
     - Создает мьютекс и условные переменные.
     - Устанавливает начальные значения для `readers_count`, `writers_waiting` и `writer_active`.

4. **Функция блокировки на чтение:**
   - `void rwlock_rdlock(rwlock_t* lock)`:
     - Блокирует rwlock для чтения.
     - Ждет, если писатель активен или есть ожидающие писатели.
     - Увеличивает счетчик активных читателей после получения блокировки.

5. **Функция блокировки на запись:**
   - `void rwlock_wrlock(rwlock_t* lock)`:
     - Блокирует rwlock для записи.
     - Увеличивает счетчик ожидающих писателей.
     - Ждет, если есть активные читатели или другой активный писатель.
     - Активирует флаг `writer_active` после получения блокировки.

6. **Функция разблокировки:**
   - `void rwlock_unlock(rwlock_t* lock)`:
     - Разблокирует rwlock.
     - Если писатель был активен, отключает его и оповещает всех ожидающих читателей.
     - Если читатель разблокируется, уменьшает его счетчик и уведомляет ожидающего писателя, если он стал нулевым.

7. **Функция разрушения:**
   - `void rwlock_destroy(rwlock_t* lock)`:
     - Освобождает ресурсы, связанные с rwlock.
     - Уничтожает мьютекс и условные переменные.

8. **Общая характеристика:**
   - Реализация rwlock позволяет безопасно выполнять операции чтения и записи в многопоточном окружении.
   - Использует мьютексы и условные переменные для управления доступом к общим ресурсам.
   - Поддерживает параллельное чтение и ограничивает запись до тех пор, пока не завершатся все операции.
